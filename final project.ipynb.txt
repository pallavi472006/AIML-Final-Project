{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "5804be7c-a56e-4f1d-9dfc-efa0a98d5f2c",
   "metadata": {},
   "source": [
    "#resume text extrcation script \n",
    "# extract_text.py\n",
    "import fitz  # PyMuPDF\n",
    "\n",
    "def extract_text_from_pdf(pdf_path):\n",
    "    pdf_document = fitz.open(pdf_path)\n",
    "    full_text = \"\"\n",
    "    for page_num in range(len(pdf_document)):\n",
    "        page = pdf_document[page_num]\n",
    "        full_text += page.get_text()\n",
    "    return full_text\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    #sample_pdf = \"resume_sample.pdf\" sample pdf give \n",
    "    text = extract_text_from_pdf(sample_pdf)\n",
    "    print(text)\n",
    "try:\n",
    "    with open('resume_sample.pdf', 'r') as file:\n",
    "        content = file.read()\n",
    "except FileNotFoundError:\n",
    "    print(\"The file 'resume_sample.pdf' was not found.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "86dc9926-03d8-4af3-af52-260e47bdc9ab",
   "metadata": {},
   "outputs": [],
   "source": [
    "#text preprocessing using spaCy \n",
    "# preprocess_text.py\n",
    "import spacy\n",
    "\n",
    "nlp = spacy.load(\"en_core_web_sm\")\n",
    "\n",
    "def preprocess_text(text):\n",
    "    doc = nlp(text)\n",
    "    tokens = []\n",
    "    for token in doc:\n",
    "        # Remove stopwords, punctuation, and lemmatize\n",
    "        if not token.is_stop and not token.is_punct:\n",
    "            tokens.append(token.lemma_.lower())\n",
    "    return \" \".join(tokens)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    sample_text = \"Experienced software developer skilled in Python and machine learning.\"\n",
    "    preprocessed = preprocess_text(sample_text)\n",
    "    print(preprocessed)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e5e94ac8-54a3-4960-b104-4df3550fd65b",
   "metadata": {},
   "outputs": [],
   "source": [
    "#vectorising and scoring algorithm \n",
    "# ranker.py\n",
    "from sklearn.feature_extraction.text import TfidfVectorizer\n",
    "from sklearn.metrics.pairwise import cosine_similarity\n",
    "\n",
    "def rank_resumes(job_description, resume_texts):\n",
    "    \"\"\"\n",
    "    job_description: string of job description keywords\n",
    "    resume_texts: list of strings (preprocessed resume texts)\n",
    "    returns: ranked list of (index, score) tuples sorted by score (descending)\n",
    "    \"\"\"\n",
    "    vectorizer = TfidfVectorizer()\n",
    "    corpus = [job_description] + resume_texts\n",
    "    tfidf_matrix = vectorizer.fit_transform(corpus)\n",
    "    \n",
    "    # Compute cosine similarity between job description and each resume\n",
    "    job_vec = tfidf_matrix[0]\n",
    "    resume_vecs = tfidf_matrix[1:]\n",
    "    \n",
    "    scores = cosine_similarity(job_vec, resume_vecs)[0]\n",
    "    ranked = sorted(enumerate(scores), key=lambda x: x[1], reverse=True)\n",
    "    return ranked\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    job_desc = \"python machine learning data analysis software engineer\"\n",
    "    resumes = [\n",
    "        \"python developer with data experience\",\n",
    "        \"graphic designer and illustrator\",\n",
    "        \"machine learning engineer expert\"\n",
    "    ]\n",
    "    rankings = rank_resumes(job_desc, resumes)\n",
    "    print(rankings)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "497729a0-3297-473b-8ab5-9faf4d64e61f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#flask web application \n",
    "# app.py\n",
    "import os\n",
    "from flask import Flask, request, render_template, redirect, url_for, send_file, flash\n",
    "from werkzeug.utils import secure_filename\n",
    "from extract_text import extract_text_from_pdf\n",
    "from preprocess_text import preprocess_text\n",
    "from ranker import rank_resumes\n",
    "\n",
    "UPLOAD_FOLDER = \"uploads\"\n",
    "ALLOWED_EXTENSIONS = {'pdf'}\n",
    "\n",
    "app = Flask(__name__)\n",
    "app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n",
    "app.secret_key = \"replace_with_a_secure_key\"\n",
    "\n",
    "if not os.path.exists(UPLOAD_FOLDER):\n",
    "    os.makedirs(UPLOAD_FOLDER)\n",
    "\n",
    "def allowed_file(filename):\n",
    "    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n",
    "\n",
    "@app.route(\"/\", methods=[\"GET\", \"POST\"])\n",
    "def index():\n",
    "    if request.method == \"POST\":\n",
    "        job_description = request.form.get(\"job_description\")\n",
    "        files = request.files.getlist(\"resumes\")\n",
    "        if not job_description or not files:\n",
    "            flash(\"Please enter a job description and upload at least one resume.\")\n",
    "            return redirect(request.url)\n",
    "        \n",
    "        resume_texts = []\n",
    "        filenames = []\n",
    "        for file in files:\n",
    "            if file and allowed_file(file.filename):\n",
    "                filename = secure_filename(file.filename)\n",
    "                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n",
    "                file.save(filepath)\n",
    "                text = extract_text_from_pdf(filepath)\n",
    "                preprocessed = preprocess_text(text)\n",
    "                resume_texts.append(preprocessed)\n",
    "                filenames.append(filename)\n",
    "        \n",
    "        rankings = rank_resumes(preprocess_text(job_description), resume_texts)\n",
    "\n",
    "        ranked_resumes = [{\"filename\": filenames[idx], \"score\": score} for idx, score in rankings]\n",
    "\n",
    "        return render_template(\"results.html\", rankings=ranked_resumes, job_description=job_description)\n",
    "    return render_template(\"index.html\")\n",
    "\n",
    "@app.route(\"/download-report\")\n",
    "def download_report():\n",
    "    # For simplicity, provide a sample CSV report\n",
    "    import csv\n",
    "    from io import StringIO\n",
    "\n",
    "    ranked_list = request.args.get('ranked', default='', type=str)\n",
    "\n",
    "    # This example assumes ranked_list is a serialized JSON string (could be improved)\n",
    "    # Implement report generation logic here\n",
    "\n",
    "    output = StringIO()\n",
    "    writer = csv.writer(output)\n",
    "    writer.writerow([\"Resume Filename\", \"Score\"])\n",
    "    # Dummy data demonstration\n",
    "    writer.writerow([\"resume1.pdf\", 0.95])\n",
    "    writer.writerow([\"resume2.pdf\", 0.80])\n",
    "    output.seek(0)\n",
    "\n",
    "    return send_file(\n",
    "        output,\n",
    "        mimetype=\"text/csv\",\n",
    "        as_attachment=True,\n",
    "        attachment_filename=\"ranking_report.csv\"\n",
    "    )\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    app.run(debug=True)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "07822e16-196e-40f8-81e7-58e04f86e3dd",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
